Blokus Pygame: 

1. Game loop - initialized gameloop ✓
2. Board display - got a basic board ✓
3. Pieces - defined all 21 piece shapes ✓
4. Piece transformations - implement rotate, flip, normalize ✓
5. Piece rendering - draw pieces on board visually
6. Player class - track pieces, color, score, starting corner
7. Mouse input - detect clicks, convert to board coordinates
8. Piece selection UI - let player choose which piece to place
9. Piece placement preview - show piece on hover before placement
    - Maybe it could snap to the nearest valid placement?
10. Core validation - implement can_place() logic: ✓
    - Bounds checking ✓
    - No overlap ✓
    - First move touches starting corner ✓
    - Corner-to-corner rule (same color) ✓
    - No edge-to-edge rule (same color) ✓
11. Place piece on board - update grid when valid placement ✓
12. Turn management - switch between players, skip if no valid moves
13. Valid move detection - check if player has any legal moves left
    - Probably start checking with smallest pieces and implement early exit
14. Game over logic - end game when all players blocked
15. Scoring - count remaining squares, determine winner
16. UI polish - show current player, remaining pieces, scores
17. Testing & debugging - validate all rules work correctly 


Blokus AI (Reinforcement Learning):

Will iron out after game logic done. 



Blokus Rules of Play: (From Wikipedia)

The standard rules of play for all variations of the game are as follows:

    - Order of play is based on the color of pieces: blue, yellow, red, green.

    - The first piece played of each color is placed in one of the board's four corners. 
      Each new piece played must be placed so that it touches at least one piece of the same color by at least one corner — only 
      corner-to-corner contact is allowed between pieces of the same color. 
      On the other hand, there are no restrictions on how pieces of different colors touch each other.

    - When a player cannot place a piece, they cannot play until the end of the game, and play continues for the other players. 
      The game ends when no one can place any more pieces.






Design Patterns to Follow:

1. Model-View-Controller (MVC) - Separate your game logic (Board, Piece, Player classes) from rendering (PyGame display). This makes testing and modifications easier.

2. State Pattern - Manage different game states (menu, playing, waiting for input, game over). This keeps your main game loop clean.

3. Observer Pattern - Notify players or the UI when the board changes, without tight coupling.

4. Strategy Pattern - Useful for implementing different AI players with varying difficulty levels.

5. Factory Pattern - Create different piece types and shapes systematically.
